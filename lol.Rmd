---
title: "League of Legends Data Analysis"
author: "Vincent Quenneville-BÃ©lair"
date: "March, 2016"
output: html_document
---

Loading packages.
```{r}
# https://cran.r-project.org/web/packages/tidyjson/vignettes/introduction-to-tidyjson.html
# https://github.com/sailthru/tidyjson
library("tidyjson")

library(plyr)
library(magrittr)
library(tidyr)
library(dplyr)
library(stringr)

library(ggplot2)
library(rattle)

library(prob)
library(caret)
library(pROC)
```

```{r}
# Read RIOT API key
# riot.key <- readLines("riot.key")
# options("riot.key" = riot.key)
```

Load match file.
```{r}
# TidyJSON
# data.file <- "data/matches1.json"
data.file <- "data/matches_all.json"
data.json <- read_json(data.file)
```

Load match data.
```{r}
data.match <- data.json %>% 
  gather_array("file.index") %>%
  enter_object("matches") %>%
  gather_array("matches.index") %>% 
  spread_values(matchId = jnumber("matchId")) %>%
  select(matchId) 

# Print general match information
data.match %>%
  spread_values(mapId = jnumber("mapId"),
                matchDuration = jnumber("matchDuration"),
                matchMode = jstring("matchMode"),
                matchType = jstring("matchType"),
                queueType = jstring("queueType"),
                region = jstring("region"),
                season = jstring("season")) %>%
  head()
```

Match duration
```{r}
data.match %>%
  spread_values(matchDuration = jnumber("matchDuration")) %>%
  mutate(matchDuration = matchDuration/60) %>%
  select(matchDuration) %>%
  summary

#  matchDuration  
#  Min.   :27.33  
#  1st Qu.:31.83  
#  Median :35.01  
#  Mean   :35.99  
#  3rd Qu.:38.62  
#  Max.   :52.15  

match.duration <- data.match %>%
  spread_values(matchDuration = jnumber("matchDuration")) %>%
  mutate(matchDuration = matchDuration/60) 

summary(match.duration$matchDuration/60)
```


We make a data frame for events.
```{r}
match.events <- data.match %>%
  enter_object("timeline") %>%
  enter_object("frames") %>%
  gather_array("frames.index") %>%
  enter_object("events") %>%
  gather_array("events.index") %>%
  select(matchId) %>%
  spread_values(eventType = jstring("eventType"),
                timestamp = jnumber("timestamp"),
                teamId = jnumber("teamId"),
                participantId = jnumber("participantId"), 
                creatorId = jnumber("creatorId"),
                victimId = jnumber("victimId"),
                killerId = jnumber("killerId"),
                monsterType = jstring("monsterType"),
                position = jstring("position"),
                towerType = jstring("towerType"),
                buildingType = jstring("buildingType")) %>%
  mutate(timestamp = timestamp/1000/60)
```

## Conditional Probabilities

We make the table of winner per match.
```{r}
# Extract per team information
data.team <- data.match %>%
  enter_object("teams") %>%
  gather_array("teams.index") %>% 
  spread_values(
    teamId = jnumber("teamId"),
    winner = jlogical("winner"),
    firstTower = jlogical("firstTower"),
    firstBaron = jlogical("firstBaron"),
    firstBlood = jlogical("firstBlood"),
    firstDragon = jlogical("firstDragon"),
    firstInhibitor = jlogical("firstInhibitor"),
    firstRiftHerald = jlogical("firstRiftHerald")) %>%
  select(-teams.index)

# Show a little more stat
data.team %>%
  spread_values(
    towerKills = jnumber("towerKills"), 
    riftHeraldKills = jnumber("riftHeraldKills"), 
    firstTower = jnumber("firstTower"),
    inhibitorKills = jnumber("inhibitorKills"), 
    dragonKills = jnumber("dragonKills"), 
    baronKills = jnumber("baronKills")) %>%
  head()

#      matchId teamId winner firstTower firstBaron firstBlood firstDragon firstInhibitor firstRiftHerald towerKills riftHeraldKills
# 1 2055016505    100   TRUE      FALSE       TRUE       TRUE        TRUE           TRUE           FALSE         10               0
# 2 2055016505    200  FALSE       TRUE      FALSE      FALSE       FALSE          FALSE           FALSE          4               0
# 3 2055016716    100   TRUE       TRUE      FALSE       TRUE        TRUE           TRUE           FALSE         11               0
# 4 2055016716    200  FALSE      FALSE      FALSE      FALSE       FALSE          FALSE           FALSE          1               0
# 5 2055016717    100  FALSE      FALSE      FALSE      FALSE       FALSE          FALSE           FALSE          3               0
# 6 2055016717    200   TRUE       TRUE      FALSE       TRUE        TRUE           TRUE           FALSE          9               0
#   firstTower.1 inhibitorKills dragonKills baronKills
# 1            0              1           4          1
# 2            1              0           0          1
# 3            1              3           3          0
# 4            0              0           0          0
# 5            0              0           2          0
# 6            1              1           2          0

match.winner <- data.team %>%
  select(matchId, teamId, winner)

team.probspace <- probspace(data.team)

Prob(team.probspace, event = winner == TRUE, given = teamId == 200)
Prob(team.probspace, event = winner == TRUE, given = teamId == 100)

# [1] 0.492
# [1] 0.508
```

Conditional probabilities on various objectives
```{r}
first.blood <- data.frame(eventType = "First Blood", 
                          probs = 100 * Prob(team.probspace, event = winner == TRUE, given = firstBlood == TRUE))
first.dragon <- data.frame(eventType = "First Dragon", 
                           probs = 100 * Prob(team.probspace, event = winner == TRUE, given = firstDragon == TRUE))
first.tower <- data.frame(eventType = "First Tower", 
                          probs = 100 * Prob(team.probspace, event = winner == TRUE, given = firstTower == TRUE))
first.herald <- data.frame(eventType = "First Herald", 
                           probs = 100 * Prob(team.probspace, event = winner == TRUE, given = firstRiftHerald == TRUE))
first.baron <- data.frame(eventType = "First Baron", 
                          probs = 100 * Prob(team.probspace, event = winner == TRUE, given = firstBaron == TRUE))
first.inhibitor <- data.frame(eventType = "First Inhibitor", 
                              probs = 100 * Prob(team.probspace, event = winner == TRUE, given = firstInhibitor == TRUE))

first <- rbind(first.blood, first.tower, first.dragon, first.herald, first.baron) # , first.inhibitor)
first <- transform(first, eventType = reorder(eventType, probs))
first$color <- c(TRUE, TRUE, TRUE, TRUE, FALSE)

#      eventType    probs color
# 1  First Blood 61.10000  TRUE
# 2  First Tower 68.20000  TRUE
# 3 First Dragon 69.48640  TRUE
# 4 First Herald 74.48980  TRUE
# 5  First Baron 82.53425 FALSE

p <- ggplot(first, aes(eventType, probs, fill = color)) +
  # expand_limits(y = c(50,100)) +
  geom_bar(stat = "identity") +
  scale_fill_discrete(guide = 'none') +
  xlab("") +
  ylab("Probability of winning given ...")
  # geom_vline(xintercept = 4.5)
  # geom_vline(xintercept = (which(first$eventType == 'First Herald') + which(first$eventType == 'First Baron'))/2)

print(p)
ggsave("figures/conditional.png", width = 8, height = 4.5, units = "in")
```

Plotting one of them.
```{r}
win <- Prob(team.probspace, event = winner == TRUE)
winANDherald <- Prob(team.probspace, event = winner == TRUE & firstRiftHerald == TRUE)
herald <- Prob(team.probspace, event = firstRiftHerald == TRUE)

require(venneuler)
v <- venneuler(c(Win = win - winANDherald, Herald = herald - winANDherald, "Win&Herald" = winANDherald))
plot(v)
```

## Surrender 

Proportion of matches that ends in surrender. A team who lost and still had at least one Nexus tower surrendered. We assume all surrenders are as such.
```{r}
# Extract tower information to infer whether losing team surrendered
match.turret <- match.events %>%
  filter(towerType == "NEXUS_TURRET") %>%
  mutate(NEXUS_TURRET = 1) %>%
  select(matchId, teamId, NEXUS_TURRET)

match.surrender <- merge(match.winner, match.turret, all.x = TRUE) %>%
  group_by(matchId, teamId, winner) %>%
  summarise_each(funs(sum)) %>%
  mutate(surrender = ifelse(winner, FALSE, 
                            ifelse(NEXUS_TURRET < 2 | is.na(NEXUS_TURRET), TRUE, FALSE))) %>%
  group_by(matchId) %>%
  summarise_each(funs(sum)) %>%
  select(matchId, surrender) %>%
  mutate(surrender = as.logical(surrender))

timeline.surrender <- merge(match.duration, match.surrender) %>%
  group_by(surrender) %>%
  summarise_each(funs(median)) %>%
  mutate(eventType = ifelse(surrender, "SURRENDER", "CASTLE DESTRUCTION"),
         timestamp = matchDuration) %>%
  select(timestamp, eventType)

# Percent of matches that ended in surrender?
x <- match.surrender$surrender
print(sum(x) / length(x) * 100)
```

## Timeline

When are certain objectives achieved for the time in a match?
```{r}
# BARON_NASHOR, BLUE_GOLEM, DRAGON, RED_LIZARD, RIFTHERALD, VILEMAW
match.events %>%
  filter(monsterType == "DRAGON") %>%
  select(matchId, timestamp) %>%
  group_by(matchId) %>%
  mutate(rank = rank(timestamp, na.last = TRUE, ties.method = "first")) %>%
  filter(rank == 1) %>%
  select(-rank)

# Length of games
timeline.end <- match.duration %>%
  summarise(timestamp = median(matchDuration)) %>%
  mutate(eventType = "END")

# Compute median time when first tower is destroyed
timeline.tower <- match.events %>% 
  filter(eventType == "BUILDING_KILL") %>%
  select(matchId, timestamp) %>%
  group_by(matchId) %>%
  mutate(rank = rank(timestamp, na.last = TRUE, ties.method = "first")) %>%
  filter(rank == 1) %>%
  as.data.frame() %>%
  select(timestamp) %>%
  summarise_each(funs(median)) %>%
  mutate(eventType = "TOWER DESTRUCTION")

# Compute median time when first tower is destroyed
timeline.inhibitor <- match.events %>% 
  filter(buildingType == "INHIBITOR_BUILDING") %>%
  select(matchId, timestamp) %>%
  group_by(matchId) %>%
  mutate(rank = rank(timestamp, na.last = TRUE, ties.method = "first")) %>%
  filter(rank == 1) %>%
  as.data.frame() %>%
  select(timestamp) %>%
  summarise_each(funs(median)) %>%
  mutate(eventType = "INHIBITOR DESTRUCTION")

# Compute median time when first elite monster is killed
timeline.monster <- match.events %>%
  filter(eventType == "ELITE_MONSTER_KILL") %>%
  select(matchId, timestamp, monsterType) %>%
  group_by(matchId, monsterType) %>%
  mutate(rank = rank(timestamp, na.last = TRUE, ties.method = "first")) %>%
  filter(rank == 1) %>%
  as.data.frame() %>%
  select(timestamp, monsterType) %>%
  group_by(monsterType) %>%
  summarise_each(funs(median)) %>%
  mutate(eventType = monsterType) %>%
  select(-monsterType) %>%
  mutate(eventType = str_replace(eventType, "DRAGON", "DRAGON KILL"),
         eventType = str_replace(eventType, "BARON_NASHOR", "BARON KILL"),
         eventType = str_replace(eventType, "RIFTHERALD", "HERALD KILL"))

# Compute the median time to draw first blood
timeline.kill <- match.events %>%
  filter(eventType == "CHAMPION_KILL") %>% 
  select(matchId, timestamp) %>%
  group_by(matchId) %>%
  mutate(rank = rank(timestamp, na.last = TRUE, ties.method = "first")) %>%
  filter(rank == 1) %>%
  as.data.frame() %>%
  summarise(timestamp = median(timestamp)) %>%
  mutate(eventType = "CHAMPION KILL")

# Compute the median time to reach level 18
timeline.maxlvl <- match.events %>%
  filter(eventType == "SKILL_LEVEL_UP") %>%
  mutate(teamId = ifelse(participantId <= 5, 100, 200)) %>%
  select(matchId, timestamp, teamId) %>%
  group_by(matchId, teamId) %>%
  mutate(rank = rank(timestamp, na.last = TRUE, ties.method = "first")) %>%
  filter(rank == 5*18)

# Print proporitions of game reaching level 18
x <- length(unique(timeline.maxlvl$matchId))
n <- length(data.match$matchId)
print(x/n * 100)
# [1] 6.3

# Add to timeline
timeline.maxlvl <- timeline.maxlvl %>%
  as.data.frame() %>%
  summarise(timestamp = median(timestamp)) %>%
  mutate(eventType = "MAX LEVEL")

# Compute the median level reached
match.events %>%
  filter(eventType == "SKILL_LEVEL_UP") %>%
  mutate(teamId = ifelse(participantId <= 5, 100, 200)) %>%
  select(matchId, timestamp, teamId) %>%
  group_by(matchId, teamId) %>%
  mutate(rank = rank(timestamp, na.last = TRUE, ties.method = "first")) %>%
  select(-timestamp) %>%
  summarise_each(funs(max(rank))) %>%
  as.data.frame() %>%
  summarise(rank = median(rank)/5)

#   rank
# 1 15.5

timeline <- rbind(timeline.monster, timeline.kill, timeline.maxlvl, timeline.surrender, timeline.tower)
            # timeline.inhibitor
timeline <- timeline[order(timeline$timestamp),]

#   timestamp          eventType
#       (dbl)              (chr)
# 1  3.154658      CHAMPION KILL
# 2 12.928967        DRAGON KILL
# 3 16.296100        HERALD KILL
# 4 25.475000          SURRENDER
# 5 29.355583         BARON KILL
# 6 33.416667 CASTLE DESTRUCTION
# 7 44.567367          MAX LEVEL
  
# Draw timeline
# http://stackoverflow.com/questions/7492274/draw-a-chronological-timeline-with-ggplot2

# dislocations <- sample(c(-1,-.5,.5,1), dim(timeline)[1], replace = T)
dislocations <- c(1.0, -1.0, 0.5, -0.5, 1.0, -1.0, 0.5, -0.5)
nudges <- 0.1 * sign(dislocations)

p <- ggplot(timeline) + 
  geom_text(aes(x = timestamp, y = dislocations, label = eventType), 
            position = position_nudge(y = nudges)) +
  geom_hline(yintercept = 0, color = "purple") +
  geom_segment(aes(x = timestamp, y = dislocations, xend = timestamp, yend = 0)) +
  xlab("minutes") +
  scale_x_continuous(expand = c(.15, .15))

p <- p + 
  theme(panel.grid.minor.y = element_blank(),
        panel.grid.major.y = element_blank(),
        axis.line = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        axis.title.y = element_blank(),
        legend.position = "none")

print(p)
ggsave("figures/timeline.png", width = 8, height = 4.5, units = "in")
```

## Scatter plot

```{r}
# Delta fields refer to values for the specified period (e.g., the gold per minute over the first 10 minutes of the game versus the second 20 minutes of the game) 
# Diffs fields refer to the deltas versus the calculated lane opponent(s)

participants.timeline <- data.match %>%
  enter_object("participants") %>%
  gather_array("participants.index") %>%
  spread_values(participantId = jnumber("participantId"),
                teamId = jnumber("teamId")) %>%
  enter_object("timeline")

participants.creeps <- participants.timeline %>% 
  enter_object("creepsPerMinDeltas") %>%
  gather_keys("ParticipantTimelineData") %>%
  append_values_number("creepsPerMinDeltas")

participants.gold <- participants.timeline %>% 
  enter_object("goldPerMinDeltas") %>%
  gather_keys("ParticipantTimelineData") %>%
  append_values_number("goldPerMinDeltas")

# participants.wards <- participants.timeline %>% 
#   enter_object("wardsPerMinDeltas") %>%
#   gather_keys("ParticipantTimelineData") %>%
#   append_values_number("ParticipantTimelineValue")

participants.xp <- participants.timeline %>% 
  enter_object("xpPerMinDeltas") %>%
  gather_keys("ParticipantTimelineData") %>%
  append_values_number("xpPerMinDeltas")

# participants.kills <- participants.timeline %>% 
#   enter_object("assistedLaneKillsPerMinDeltas") %>%
#   gather_keys("ParticipantTimelineData") %>%
#   append_values_number("assistedLaneKillsPerMinDeltas")

participants <- merge(participants.creeps, participants.gold)
participants <- merge(participants, participants.xp)

participants <- merge(participants, match.winner) %>%
  select(matchId, teamId, ParticipantTimelineData, creepsPerMinDeltas, goldPerMinDeltas, xpPerMinDeltas, winner) %>%
  group_by(matchId, teamId, ParticipantTimelineData, winner) %>%
  summarise_each(funs(mean)) %>%
  filter(ParticipantTimelineData == "zeroToTen" | ParticipantTimelineData == "tenToTwenty") %>%
  as.data.frame() %>%
  select(-ParticipantTimelineData) %>%
  group_by(matchId, teamId, winner) %>%
  summarise_each(funs(mean))

#       matchId teamId winner creepsPerMinDeltas goldPerMinDeltas xpPerMinDeltas
#         (dbl)  (dbl)  (lgl)              (dbl)            (dbl)          (dbl)
# 1  2054994176    100  FALSE               3.66           270.78         359.19
# 2  2054994176    200   TRUE               4.15           320.34         387.32
# 3  2054994196    100  FALSE               3.55           318.21         402.64
# 4  2054994196    200   TRUE               4.08           332.82         385.74
# 5  2054994244    100  FALSE               3.27           255.12         372.72
# 6  2054994244    200   TRUE               4.10           329.23         424.98
# 7  2054994283    100  FALSE               3.54           255.87         364.14
# 8  2054994283    200   TRUE               4.52           336.31         415.82
# 9  2054994354    100  FALSE               3.78           304.94         358.04
# 10 2054994354    200   TRUE               3.41           299.32         378.73
# ..        ...    ...    ...                ...              ...            ...

ggplot(participants, aes(goldPerMinDeltas, xpPerMinDeltas, color = factor(winner), group = factor(winner))) + 
  geom_point(alpha = 0.2, size = 1) +
  geom_density2d(alpha = 1) +
  # stat_density2d() +
  # stat_density2d(aes(alpha = ..density..), geom = "raster", contour = FALSE)
  # geom_bin2d(aes(color = ..count..), binwidth = 5, alpha = 0.5) +
  # stat_bin2d(binwidth = 5, alpha = 0.5) +
  xlab("Gold per min in first 20 min") +
  ylab("Experience per min in first 20 min")
```

## Prediction

We prepare the data frame with each row being one match and goal to predict winning team.
```{r}
data <- data.team %>%
  mutate(winner = winner * teamId,
         firstBaron = firstBaron * teamId,
         firstBlood = firstBlood * teamId,
         firstDragon = firstDragon * teamId,
         firstInhibitor = firstInhibitor * teamId,
         firstTower = firstTower * teamId,
         firstRiftHerald = firstRiftHerald * teamId) %>%
  group_by(matchId) %>%
  summarise_each(funs(sum)) %>%
  select(-teamId) %>%
  mutate_each(funs(factor)) %>%
  select(winner,
         # firstBaron,
         # firstInhibitor,
         firstBlood,
         firstDragon,
         firstTower,
         firstRiftHerald)
```

We divide the dataset into train and test.
```{r}
set.seed(1)

training.index <- createDataPartition(data$winner, p = .8, list = FALSE)
training <- data[ training.index,]
testing  <- data[-training.index,]

# Enough features?
nrow(training)/ncol(training)
```

We create dummy variables for categorical variables.
```{r}
# dummies <- dummyVars(~ ., data = training, sep = "__", drop2nd = TRUE)
# training <- data.frame(predict(dummies, training))
# testing <- data.frame(predict(dummies, testing))
# 
# # Enough features?
# nrow(training)/ncol(training)
```

We cross-validate.
```{r}
# Select method
# method <- "rf"
method <- "rpart"
# method <- "glmnet"
# method <- "svmLinear"
# method <- "svmRadial"

if (method == "rf") {
  modelGrid <- expand.grid(mtry = seq(0, 5, by = 1))
} else if (method == "rpart") {
  modelGrid <- expand.grid(cp = seq(0.01, 0.1, by = 0.01))
} else if (method == "glmnet") {
  # alpha between 0 (ridge) and 1 (lasso)
  modelGrid <- expand.grid(.alpha = c(0, 0.1, 0.5, 0.7, 1), .lambda = seq(0, 10, by = 0.1))
} else if (method == "svmLinear") {
  modelGrid <- expand.grid(C = seq(0.5, 5, by = 0.5))
} else if (method == "svmRadial") {
  modelGrid <- expand.grid(C = seq(0.5, 5, by = 0.5), sigma = seq(0.1, 0.5, by = 0.1))
}

# Cross-validation parameters
ctrl <- trainControl(method = "cv", number = 10, verboseIter = T)

# We can try different methods: svmLinear glmnet rpart svmRadial
modelTune <- train(winner ~ .,
                   data = training,
                   tuneGrid = modelGrid,
                   trControl = ctrl,
                   method = method,
                   # summaryFunction = twoClassSummary,
                   # metric = "ROC",
                   # classProbs = TRUE,
                   # importance = TRUE,
                   # scale = FALSE,
                   na.action = na.pass)

modelTune
varImp(modelTune)
plot(modelTune)

modelTune$bestTune
plot(modelTune$results)

par(mfrow = c(1,1))
plot(modelTune$finalModel)

fancyRpartPlot(modelTune$finalModel)
```

We evaluate using the ROC curve.
```{r}
probsTrain <- predict(modelTune,
                      training,
                      type = "prob",
                      na.action = na.pass)

rocCurve   <- roc(response = training$winner,
                      predictor = probsTrain$"200",
                      levels = rev(levels(training$winner)))

names(rocCurve)
rocCurve$thresholds
rocCurve$sensitivity

# Choose threshold according to sensitivity or specificity
# qplot(x = rocCurve$thresholds, y = rocCurve$sensit)
# qplot(x = rocCurve$thresholds, y = rocCurve$spec)

# Plot ROC curve
plot(rocCurve, print.thres = "best")
```

We now predict on the test set.
```{r}
modelPredict <- predict(modelTune,
                        newdata = testing,
                        # type = "prob",
                        na.action = na.pass)

# thresold <- 0.7
# modelPredict <- modelPredict %>%
#   mutate(class = ifelse("200" > thresold, "200", "100")) %>%
#   mutate(class = as.factor(class))

par(mfrow = c(1,1))
plot(modelPredict)

table(predict = modelPredict, true = testing$winner)
confusionMatrix(modelPredict, testing$winner, positive = "200")
```