---
title: "League of Legends Data Analysis"
author: "Vincent Quenneville-BÃ©lair"
date: "March, 2016"
output: html_document
---

Loading packages.
```{r}
# https://cran.r-project.org/web/packages/tidyjson/vignettes/introduction-to-tidyjson.html
# https://github.com/sailthru/tidyjson
library("tidyjson")

library(plyr)
library(tidyr)
library(dplyr)
library(stringr)

library(ggplot2)
library(rattle)

library(caret)
library(pROC)
```

```{r}
# Read RIOT API key
# riot.key <- readLines("riot.key")
# options("riot.key" = riot.key)
```

Load match file.
```{r}
# TidyJSON
# data.file <- "data/matches1.json"
data.file <- "data/matches_all.json"
data.json <- read_json(data.file)
```

Load information from each match.
```{r}
data.match <- data.json %>% 
  gather_array("file.index") %>%
  enter_object("matches") %>%
  gather_array("matches.index") %>% 
  spread_values(matchId = jnumber("matchId")) %>%
  select(matchId) %>%
  spread_values(mapId = jnumber("mapId"),
                matchDuration = jnumber("matchDuration"),
                matchMode = jstring("matchMode"),
                matchType = jstring("matchType"),
                queueType = jstring("queueType"),
                region = jstring("region"))

data.match %>%
  filter(matchId == 2054994244) %>%
  head()
```

Make data frame for first objectives.
```{r}
team <- data.match %>%
  enter_object("teams") %>%
  gather_array("teams.index") %>% 
  spread_values(
    teamId = jnumber("teamId"),
    winner = jlogical("winner"),
    towerKills = jnumber("towerKills"), 
    riftHeraldKills = jnumber("riftHeraldKills"), 
    inhibitorKills = jnumber("inhibitorKills"), 
    dragonKills = jnumber("dragonKills"), 
    baronKills = jnumber("baronKills"), 
    firstBaron = jlogical("firstBaron"),
    firstBlood = jlogical("firstBlood"),
    firstDragon = jlogical("firstDragon"),
    firstInhibitor = jlogical("firstInhibitor"),
    firstRiftHerald = jlogical("firstRiftHerald"))

team %>%
  filter(matchId == 2054994244) %>%
  summary()

data <- team %>%
  select(matchId, 
         teamId,
         winner,
         firstBaron,
         firstBlood,
         firstDragon,
         firstTower,
         firstInhibitor,
         firstRiftHerald) %>%
  mutate(winner = winner * teamId,
         firstBaron = firstBaron * teamId,
         firstBlood = firstBlood * teamId,
         firstDragon = firstDragon * teamId,
         firstInhibitor = firstInhibitor * teamId,
         firstTower = firstTower * teamId,
         firstRiftHerald = firstRiftHerald * teamId) %>%
  group_by(matchId) %>%
  summarise_each(funs(sum)) %>%
  select(-teamId) %>%
  mutate_each(funs(factor))

#       matchId winner firstBaron firstBlood firstDragon firstInhibitor firstRiftHerald
#        (fctr) (fctr)     (fctr)     (fctr)      (fctr)         (fctr)          (fctr)
# 1  2054994244    200        100        200         200            200               0
# 2  2054994283    200        200        200         200            200               0
# 3  2054994354    200        200        100         100            200             100
# 4  2054994531    200        200        100         100            100               0
# 5  2054994735    200        200        100         200            100               0
# 6  2054994812    200        100        200         200            100               0
# 7  2054994893    200        200        100         100            200               0
# 8  2054994964    100        200        100         100            100               0
# 9  2054994984    100        200        100         200            100               0
# 10 2054995158    200        100        200         200            200               0
# ..        ...    ...        ...        ...         ...            ...             ...
```

Is there an advantage being on the blue/red side?
```{r}
data %>% 
  select(winner) %>%
  summary()
```

```{r}
data <- data %>%
  select(winner,
         # firstBaron,
         firstBlood,
         firstDragon,
         firstTower,
         # firstInhibitor,
         firstRiftHerald)
```

# Prediction

We divide the dataset into train and test.
```{r}
data <- data %>% select(-matchId)
set.seed(1)

training.index <- createDataPartition(data$winner, p = .8, list = FALSE)
training <- data[ training.index,]
testing  <- data[-training.index,]

# Enough features?
nrow(training)/ncol(training)
```

We create dummy variables for categorical variables.
```{r}
# dummies <- dummyVars(~ ., data = training, sep = "__", drop2nd = TRUE)
# training <- data.frame(predict(dummies, training))
# testing <- data.frame(predict(dummies, testing))
# 
# # Enough features?
# nrow(training)/ncol(training)
```

```{r}
# Cross-Validation
ctrl <- trainControl(method = "cv", number = 10, verboseIter = T)

# Select method
# method <- "rf"
# method <- "rpart"
method <- "glmnet"
# method <- "svmLinear"
# method <- "svmRadial"

if (method == "rf") {
  modelGrid <- expand.grid(mtry = seq(0, 5, by = 1))
} else if (method == "rpart") {
  modelGrid <- expand.grid(cp = seq(0.01, 0.1, by = 0.01))
} else if (method == "glmnet") {
  # alpha between 0 (ridge) and 1 (lasso)
  modelGrid <- expand.grid(.alpha = c(0, 0.1, 0.5, 0.7, 1), .lambda = seq(0, 10, by = 0.1))
} else if (method == "svmLinear") {
  modelGrid <- expand.grid(C = seq(0.5, 5, by = 0.5))
} else if (method == "svmRadial") {
  modelGrid <- expand.grid(C = seq(0.5, 5, by = 0.5), sigma = seq(0.1, 0.5, by = 0.1))
}

# We can try different methods: svmLinear glmnet rpart svmRadial
modelTune <- train(winner ~ .,
                   data = training,
                   tuneGrid = modelGrid,
                   trControl = ctrl,
                   method = method,
                   # summaryFunction = twoClassSummary,
                   # metric = "ROC",
                   # classProbs = TRUE,
                   # importance = TRUE,
                   # scale = FALSE,
                   na.action = na.pass)

modelTune
varImp(modelTune)
plot(modelTune)

modelTune$bestTune
plot(modelTune$results)

par(mfrow = c(1,1))
plot(modelTune$finalModel)

# fancyRpartPlot(modelTune$finalModel)
```

We evaluate using the ROC curve.
```{r}
probsTrain <- predict(modelTune,
                      training,
                      type = "prob",
                      na.action = na.pass)

rocCurve   <- roc(response = training$winner,
                      predictor = probsTrain$"200",
                      levels = rev(levels(training$winner)))

plot(rocCurve, print.thres = "best")
```

```{r}
names(rocCurve)
rocCurve$thresholds
rocCurve$sensitivity

# choose threshold
qplot(x = rocCurve$thresholds, y = rocCurve$sensit)
qplot(x = rocCurve$thresholds, y = rocCurve$spec)
```

We now predict on the test set.
```{r}
modelPredict <- predict(modelTune,
                        newdata = testing,
                        # type = "prob",
                        na.action = na.pass)

# thresold <- 0.7
# modelPredict <- modelPredict %>%
#   mutate(class = ifelse("200" > thresold, "200", "100")) %>%
#   mutate(class = as.factor(class))

par(mfrow = c(1,1))
plot(modelPredict)

table(predict = modelPredict, true = testing$winner)

rtCM <- confusionMatrix(modelPredict, testing$winner, positive = "200")
rtCM
```

Helper functions for manipulating columns.
```{r}
# Convert to numeric
convert.numeric <- function(x) {
  as.numeric(as.character(x))
}

# Remove incomplete cases
complete.remove <- function(x) {
  x <- x[complete.cases(x),]  
}

# Convert to string without factors
convert.char <- function(x) {
  data.frame(lapply(x, as.character), stringsAsFactors=FALSE) 
}
```

```{r}
# Delta fields refer to values for the specified period (e.g., the gold per minute over the first 10 minutes of the game versus the second 20 minutes of the game) 
# Diffs fields refer to the deltas versus the calculated lane opponent(s)

timeline <- data.match %>%
  enter_object("participants") %>%
  gather_array("participants.index") %>%
  enter_object("timeline")

participants_creeps <- timeline %>% 
  enter_object("creepsPerMinDeltas") %>%
  gather_keys("ParticipantTimelineData") %>%
  append_values_number("creepsPerMinDeltas")

participants_gold <- timeline %>% 
  enter_object("goldPerMinDeltas") %>%
  gather_keys("ParticipantTimelineData") %>%
  append_values_number("goldPerMinDeltas")

# participants_wards <- timeline %>% 
#   enter_object("wardsPerMinDeltas") %>%
#   gather_keys("ParticipantTimelineData") %>%
#   append_values_number("ParticipantTimelineValue")

participants_xp <- timeline %>% 
  enter_object("xpPerMinDeltas") %>%
  gather_keys("ParticipantTimelineData") %>%
  append_values_number("xpPerMinDeltas")

participants <- cbind(participants_creeps, participants_gold$goldPerMinDeltas, participants_xp$xpPerMinDeltas)
names(participants)[11] <- "goldPerMinDeltas"
names(participants)[12] <- "xpPerMinDeltas"
```