---
title: "League of Legends Data Analysis"
author: "Vincent Quenneville-BÃ©lair"
date: "March, 2016"
runtime: shiny
output: html_document
---

Loading packages.
```{r}
library(gridExtra)
library(png)
library(grid)
library(ggplot2)
library(rattle)
library(shiny)

library(prob)
library(caret)
library(pROC)

library(stringr)

# https://cran.r-project.org/web/packages/tidyjson/vignettes/introduction-to-tidyjson.html
# https://github.com/sailthru/tidyjson
library("tidyjson")

library(reshape2)
library(plyr)
library(magrittr)
library(tidyr)
library(dplyr)
```

```{r}
# Extract gg color
gg_color_hue <- function(n) {
  hues = seq(15, 375, length=n+1)
  hcl(h=hues, l=65, c=100)[1:n]
}

gg_blue <- gg_color_hue(4)[3] # blue: #00BFC4
gg_red  <- gg_color_hue(4)[1] # red: F8766D
gg_purple <- gg_color_hue(4)[4]
```

```{r}
# Read RIOT API key
# riot.key <- readLines("riot.key")
# options("riot.key" = riot.key)
```

Load match file.
```{r}
# TidyJSON
# data.file <- "data/matches1.json"
data.file <- "data/matches_all.json"
data.json <- read_json(data.file)
```

Load match data.
```{r}
data.match <- data.json %>% 
  gather_array("file.index") %>%
  enter_object("matches") %>%
  gather_array("matches.index") %>% 
  spread_values(matchId = jnumber("matchId")) %>%
  select(matchId) 

# Print general match information
data.match %>%
  spread_values(mapId = jnumber("mapId"),
                matchDuration = jnumber("matchDuration"),
                matchMode = jstring("matchMode"),
                matchType = jstring("matchType"),
                queueType = jstring("queueType"),
                region = jstring("region"),
                season = jstring("season")) %>%
  head()
```

Match duration
```{r}
data.match %>%
  spread_values(matchDuration = jnumber("matchDuration")) %>%
  mutate(matchDuration = matchDuration/60) %>%
  select(matchDuration) %>%
  summary

#  matchDuration  
#  Min.   :27.33  
#  1st Qu.:31.83  
#  Median :35.01  
#  Mean   :35.99  
#  3rd Qu.:38.62  
#  Max.   :52.15  

match.duration <- data.match %>%
  spread_values(matchDuration = jnumber("matchDuration")) %>%
  mutate(matchDuration = matchDuration/60) 

summary(match.duration$matchDuration/60)
```

## Look into events

```{r}
# data.match %>%
#   enter_object("timeline") %>%
#   enter_object("frames") %>%
#   gather_array("frames.index") %>% 
#   enter_object("participantFrame") %>% str()
#   gather_array("participantFrames.index") %>% str()
#   spread_values(participantId = jnumber(participantId))
```

We make a data frame for events.
```{r}
match.events <- data.match %>%
    enter_object("timeline") %>%
    enter_object("frames") %>%
    gather_array("frames.index") %>%
    enter_object("events") %>%
    gather_array("events.index") %>%
    select(matchId) %>%
    spread_values(eventType = jstring("eventType"),
                  timestamp = jnumber("timestamp"),
                  teamId = jnumber("teamId"),
                  participantId = jnumber("participantId"), 
                  creatorId = jnumber("creatorId"),
                  victimId = jnumber("victimId"),
                  killerId = jnumber("killerId"),
                  monsterType = jstring("monsterType"),
                  towerType = jstring("towerType"),
                  buildingType = jstring("buildingType")) %>%
    mutate(timestamp = timestamp/1000/60) 

# Beware: pick up only the ones with positions available
match.events <- match.events %>%
    enter_object("position") %>%
    spread_values(X = jnumber("x"),
                  Y = jnumber("y"))
```

## Conditional Probabilities

We make the table of winner per match.
```{r}
# Extract per team information
data.team <- data.match %>%
  enter_object("teams") %>%
  gather_array("teams.index") %>% 
  spread_values(
    teamId = jnumber("teamId"),
    winner = jlogical("winner"),
    firstTower = jlogical("firstTower"),
    firstBaron = jlogical("firstBaron"),
    firstBlood = jlogical("firstBlood"),
    firstDragon = jlogical("firstDragon"),
    firstInhibitor = jlogical("firstInhibitor"),
    firstRiftHerald = jlogical("firstRiftHerald")) %>%
  select(-teams.index)

# Show a little more stat
data.team %>%
  spread_values(
    towerKills = jnumber("towerKills"), 
    riftHeraldKills = jnumber("riftHeraldKills"), 
    firstTower = jnumber("firstTower"),
    inhibitorKills = jnumber("inhibitorKills"), 
    dragonKills = jnumber("dragonKills"), 
    baronKills = jnumber("baronKills")) %>%
  head()

#      matchId teamId winner firstTower firstBaron firstBlood firstDragon firstInhibitor firstRiftHerald towerKills riftHeraldKills
# 1 2055016505    100   TRUE      FALSE       TRUE       TRUE        TRUE           TRUE           FALSE         10               0
# 2 2055016505    200  FALSE       TRUE      FALSE      FALSE       FALSE          FALSE           FALSE          4               0
# 3 2055016716    100   TRUE       TRUE      FALSE       TRUE        TRUE           TRUE           FALSE         11               0
# 4 2055016716    200  FALSE      FALSE      FALSE      FALSE       FALSE          FALSE           FALSE          1               0
# 5 2055016717    100  FALSE      FALSE      FALSE      FALSE       FALSE          FALSE           FALSE          3               0
# 6 2055016717    200   TRUE       TRUE      FALSE       TRUE        TRUE           TRUE           FALSE          9               0
#   firstTower.1 inhibitorKills dragonKills baronKills
# 1            0              1           4          1
# 2            1              0           0          1
# 3            1              3           3          0
# 4            0              0           0          0
# 5            0              0           2          0
# 6            1              1           2          0

match.winner <- data.team %>%
  select(matchId, teamId, winner)

team.probspace <- probspace(data.team)

Prob(team.probspace, event = winner == TRUE, given = teamId == 200)
Prob(team.probspace, event = winner == TRUE, given = teamId == 100)

# [1] 0.492
# [1] 0.508
```

Conditional probabilities on various objectives
```{r}
first.blood <- data.frame(eventType = "First Champion", 
                          probs = 100 * Prob(team.probspace, event = winner == TRUE, given = firstBlood == TRUE))
first.dragon <- data.frame(eventType = "First Dragon", 
                           probs = 100 * Prob(team.probspace, event = winner == TRUE, given = firstDragon == TRUE))
first.tower <- data.frame(eventType = "First Tower", 
                          probs = 100 * Prob(team.probspace, event = winner == TRUE, given = firstTower == TRUE))
first.herald <- data.frame(eventType = "First Herald", 
                           probs = 100 * Prob(team.probspace, event = winner == TRUE, given = firstRiftHerald == TRUE))
first.baron <- data.frame(eventType = "First Baron", 
                          probs = 100 * Prob(team.probspace, event = winner == TRUE, given = firstBaron == TRUE))
first.inhibitor <- data.frame(eventType = "First Inhibitor", 
                              probs = 100 * Prob(team.probspace, event = winner == TRUE, given = firstInhibitor == TRUE))

first <- rbind(first.blood, first.tower, first.dragon, first.herald, first.baron) # , first.inhibitor)
first <- transform(first, eventType = reorder(eventType, probs))
first$color <- c(TRUE, TRUE, TRUE, TRUE, FALSE)

#      eventType    probs color
# 1  First Blood 61.10000  TRUE
# 2  First Tower 68.20000  TRUE
# 3 First Dragon 69.48640  TRUE
# 4 First Herald 74.48980  TRUE
# 5  First Baron 82.53425 FALSE

p <- ggplot(first, aes(eventType, probs, fill = color)) +
  # expand_limits(y = c(50,100)) +
  geom_bar(stat = "identity") +
  scale_fill_discrete(guide = 'none') +
  coord_cartesian(ylim = c(50, 85), expand = TRUE) +
  xlab("") +
  ylab("Probability of winning given ...") +
  geom_hline(yintercept = 50, color = gg_purple)
  # geom_vline(xintercept = 4.5)
  # geom_vline(xintercept = (which(first$eventType == 'First Herald') + which(first$eventType == 'First Baron'))/2)

print(p)
ggsave("figures/conditional.png", width = 8, height = 4.5, units = "in", bg = "transparent")
```

Plot Venn diagram for winner and first Rift Herald.
```{r}
win <- Prob(team.probspace, event = winner == TRUE)
winANDherald <- Prob(team.probspace, event = winner == TRUE & firstRiftHerald == TRUE)
herald <- Prob(team.probspace, event = firstRiftHerald == TRUE)

require(venneuler)
v <- venneuler(c(Win = win - winANDherald, 
                 Herald = herald - winANDherald, 
                 "Win&Herald" = winANDherald))
plot(v, col = c(gg_blue, gg_red))
```

## Surrender 

Proportion of matches that ends in surrender. A team who lost and still had at least one Nexus tower surrendered. We assume all surrenders are as such.
```{r}
# Extract tower information to infer whether losing team surrendered
match.turret <- match.events %>%
  dplyr::filter(towerType == "NEXUS_TURRET") %>%
  mutate(NEXUS_TURRET = 1) %>%
  select(matchId, teamId, NEXUS_TURRET)

match.surrender <- merge(match.winner, match.turret, all.x = TRUE) %>%
  group_by(matchId, teamId, winner) %>%
  summarise_each(funs(sum)) %>%
  mutate(surrender = ifelse(winner, FALSE, 
                            ifelse(NEXUS_TURRET < 2 | is.na(NEXUS_TURRET), TRUE, FALSE))) %>%
  group_by(matchId) %>%
  summarise_each(funs(sum)) %>%
  select(matchId, surrender) %>%
  mutate(surrender = as.logical(surrender))

timeline.surrender <- merge(match.duration, match.surrender) %>%
  group_by(surrender) %>%
  summarise_each(funs(median)) %>%
  mutate(eventType = ifelse(surrender, "SURRENDER", "CASTLE DESTRUCTION"),
         timestamp = matchDuration) %>%
  select(timestamp, eventType)

# Percent of matches that ended in surrender?
x <- match.surrender$surrender
print(sum(x) / length(x) * 100)
```

## Activity versus time

```{r}
events <- match.events %>%
  mutate(participantId = ifelse(participantId <= 5, 100, 200),
         creatorId = ifelse(creatorId <= 5, 100, 200),
         victimId = ifelse(victimId <= 5, 200, 100),   # associate non-victim team!
         killerId = ifelse(killerId <= 5, 100, 200),
         teamId = ifelse(teamId == 100, 200, 100)  # associate to non-victim team!
         ) %>%
  # Fill in team association
  mutate(victimId      = ifelse(is.na(victimId), killerId, victimId)) %>%
  mutate(creatorId     = ifelse(is.na(creatorId), victimId, creatorId)) %>%
  mutate(participantId = ifelse(is.na(participantId), creatorId, participantId)) %>%
  mutate(teamId        = ifelse(is.na(teamId), participantId, teamId)) %>%
  select(-participantId, -creatorId, -victimId, -killerId) %>%
  # Attach winning status
  merge(match.winner, all.x = TRUE) %>%
  mutate(eventType = as.factor(eventType),
         teamId = as.factor(teamId))
```
  
Plot activity per few minutes normalized per match.
```{r}
binwidth <- 5

# Divide events in bins
bin.events <- events %>%
  # dplyr::filter(eventType == "CHAMPION_KILL")
  dplyr::filter(eventType == "ELITE_MONSTER_KILL") %>%
  mutate(bin = timestamp %/% binwidth) %>%
  group_by(winner, bin) %>%
  summarise(count = n())

# Divide matches in bins -- count in last full bin
bin.match <- match.duration %>% 
  mutate(bin = matchDuration %/% binwidth) %>%
  group_by(bin) %>%
  summarise(match = n())

bin.match <- rbind(data.frame(bin = c(0, 1), match = c(0, 0)), bin.match) %>%
  mutate(remain = sum(match) - cumsum(match))

bin <- merge(bin.events, bin.match, all.x = TRUE) %>%
  mutate(countPerMatch = ifelse(remain == 0, NA, count / remain)) %>%
  select(bin, countPerMatch, winner) %>%
  na.omit()

bin.win <- bin %>%
  filter(winner == TRUE) %>%
  select(-winner)
bin.lost <- bin %>%
  filter(winner == FALSE) %>%
  select(-winner)

# p <- ggplot() +
#   geom_bar(data = bin.win, aes(bin-0.5, countPerMatch), alpha = 0.5, fill = gg_red, stat = "identity") +
#   geom_bar(data = bin.lost, aes(bin-0.5, countPerMatch), alpha = 0.5, fill = gg_blue, stat = "identity") +
#   scale_x_continuous(breaks = seq(0, max(bin$bin), 2), 
#                    labels = seq(0, binwidth*max(bin$bin), 2*binwidth)) +
#   coord_cartesian(xlim = c(0, max(bin$bin)), expand = TRUE) +
#   ylab("events per match") +
#   xlab("minutes")

# Choice of position: dodge, identity, stack
p <- ggplot(bin, aes(bin-0.5, countPerMatch, group = winner, fill = winner)) +
  geom_bar(alpha = 0.5, stat = "identity", position = "identity") +
  scale_x_continuous(breaks = seq(0, max(bin$bin), 2), 
                   labels = seq(0, binwidth*max(bin$bin), 2*binwidth)) +
  coord_cartesian(xlim = c(0, max(bin$bin)), expand = TRUE) +
  ylab("events per match") +
  xlab("minutes")

plot(p)
```

Plot activity per few minutes.
```{r}
# Choice of position: dodge, identity, stack
p <- events %>%
  # dplyr::filter(eventType == "CHAMPION_KILL") %>%
  dplyr::filter(eventType == "ELITE_MONSTER_KILL") %>% 
  ggplot(aes(timestamp, y = ..count.., group = winner, fill = winner)) + 
  xlab("minutes") +
  stat_bin(binwidth = 5, alpha = 0.7, col = I("white"), position = "identity")

# p <- ggplot(data, aes(timestamp, 
#                       y = (..count..)/sum(..count..), group = winner, fill = winner)) + 
#   xlab("minutes") +
#   ylab("proportion for each team") +
#   stat_bin(binwidth = 5, col = I("white"), position = "fill")

plot(p)
ggsave("figures/activity.png", width = 8, height = 4.5, units = "in", bg = "transparent")

# Save for presentation
write.csv(as.data.frame(events), file = "data/events.csv")
```

## Map

We transform the coordinate given in data frame to coordinate on the image.
```{r}
# We need to apply a linear transformation 
# mapping the given coordinates to the corresponding pixels on the image

# Coordinate range in data frame
# min: {x: 0, y: 0}
# max: {x: 14820, y: 14881}
# Coordinate range on map
# min: {x: -570, y: -420}
# max: {x: 15220, y: 14980}
# Image pixel coordinates
# min: {x: 0, y: 0}
# max: {x: 512, y: 512}

f.x <- function(x) {
  # Input range -570 to 15220
  # Output range 0 to 512
  
  i.xmin = -570
  i.xmax = 15220
  o.xmin = 0
  o.xmax = 512
  
  o.xmin + (o.xmax - o.xmin) * (x - i.xmin) / (i.xmax - i.xmin)
}

f.y <- function(y) {
  # Input range -420 to 14980
  # Output range 0 to 512
  
  i.ymin = -420
  i.ymax = 14980
  o.ymin = 0
  o.ymax = 512
  
  o.ymin + (o.ymax - o.ymin) * (y - i.ymin) / (i.ymax - i.ymin)
}

# Extract the positions of all events in a given match
# ... and apply transformation to find corresponding pixel on image
coord <- events %>% 
  mutate(X = f.x(X), Y = f.y(Y))

# Save for presentation
write.csv(as.data.frame(coord), file = "data/map.csv")
```

We plot the events of a match over the map.
```{r}
make_map <- function(data) {
  
  # Get background image
  img <- readPNG("data/minimap-mh-alpha.png")
  g <- rasterGrob(img, interpolate = TRUE, width = unit(1,"npc"), height = unit(1,"npc"))
  
  # Scatter plot with background
  p <- data %>%
    ggplot(aes(X, Y, color = teamId, group = teamId)) + 
    scale_color_manual(na.value = "black", values = c(gg_blue, gg_red)) +
    # scale_color_manual(na.value = "black", values = c("blue", "red")) +
    annotation_custom(g, xmin = 0, xmax = 512, ymin = 0, ymax = 512) +
    expand_limits(x = c(0,512), y = c(0,512))
  
  # p <- p + geom_point(alpha = 0.1, size = 1)
  # p <- p + stat_density2d(aes(fill = ..level..), geom = "polygon", alpha = 0.2)
  # p <- p + stat_density2d(aes(alpha = ..level..))
  p <- p + stat_density2d(size = 1)
  
  # Remove padding and decorations
  p <- p +
    scale_y_continuous(expand = c(0,0)) + 
    scale_x_continuous(expand = c(0,0)) +
    theme(aspect.ratio = 1) +
    theme(axis.line = element_blank(),
          axis.text.x = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks = element_blank(),
          axis.title.x = element_blank(),
          axis.title.y = element_blank(),
          legend.position = "none",
          panel.background = element_blank(),
          panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          plot.background = element_blank())
}

# Pick matches to map
data <- coord %>%
  # dplyr::filter((teamId == 100 & winner == TRUE) | (teamId == 200 & winner == FALSE))
  dplyr::filter((teamId == 100 & winner == FALSE) | (teamId == 200 & winner == TRUE))

# Select one match only
# data <- coord %>%
#   dplyr::filter(matchId == 2054994244)

# Leave buildings as a separate color
# data <- data %>%
#   mutate(teamId = ifelse(eventType == "BUILDING_KILL", NA, teamId)) 

# Show and save plot
p <- make_map(data)
print(p)
ggsave("figures/events.png", width = 10, height = 10, units = "in", bg = "transparent")
```

## Timeline

When are certain objectives achieved for the time in a match?
```{r}
# BARON_NASHOR, BLUE_GOLEM, DRAGON, RED_LIZARD, RIFTHERALD, VILEMAW
match.events %>%
  dplyr::filter(monsterType == "DRAGON") %>%
  select(matchId, timestamp) %>%
  group_by(matchId) %>%
  mutate(rank = rank(timestamp, na.last = TRUE, ties.method = "first")) %>%
  dplyr::filter(rank == 1) %>%
  select(-rank)

# Length of games
timeline.end <- match.duration %>%
  summarise(timestamp = median(matchDuration)) %>%
  mutate(eventType = "END")

# Compute median time when first tower is destroyed
timeline.tower <- match.events %>% 
  dplyr::filter(eventType == "BUILDING_KILL") %>%
  select(matchId, timestamp) %>%
  group_by(matchId) %>%
  mutate(rank = rank(timestamp, na.last = TRUE, ties.method = "first")) %>%
  dplyr::filter(rank == 1) %>%
  as.data.frame() %>%
  select(timestamp) %>%
  summarise_each(funs(median)) %>%
  mutate(eventType = "TOWER DESTRUCTION")

# Compute median time when first tower is destroyed
timeline.inhibitor <- match.events %>% 
  dplyr::filter(buildingType == "INHIBITOR_BUILDING") %>%
  select(matchId, timestamp) %>%
  group_by(matchId) %>%
  mutate(rank = rank(timestamp, na.last = TRUE, ties.method = "first")) %>%
  dplyr::filter(rank == 1) %>%
  as.data.frame() %>%
  select(timestamp) %>%
  summarise_each(funs(median)) %>%
  mutate(eventType = "INHIBITOR DESTRUCTION")

# Compute median time when first elite monster is killed
timeline.monster <- match.events %>%
  dplyr::filter(eventType == "ELITE_MONSTER_KILL") %>%
  select(matchId, timestamp, monsterType) %>%
  group_by(matchId, monsterType) %>%
  mutate(rank = rank(timestamp, na.last = TRUE, ties.method = "first")) %>%
  dplyr::filter(rank == 1) %>%
  as.data.frame() %>%
  select(timestamp, monsterType) %>%
  group_by(monsterType) %>%
  summarise_each(funs(median)) %>%
  mutate(eventType = monsterType) %>%
  select(-monsterType) %>%
  mutate(eventType = str_replace(eventType, "DRAGON", "DRAGON KILL"),
         eventType = str_replace(eventType, "BARON_NASHOR", "BARON KILL"),
         eventType = str_replace(eventType, "RIFTHERALD", "HERALD KILL"))

# Compute the median time to draw first blood
timeline.kill <- match.events %>%
  dplyr::filter(eventType == "CHAMPION_KILL") %>% 
  select(matchId, timestamp) %>%
  group_by(matchId) %>%
  mutate(rank = rank(timestamp, na.last = TRUE, ties.method = "first")) %>%
  dplyr::filter(rank == 1) %>%
  as.data.frame() %>%
  summarise(timestamp = median(timestamp)) %>%
  mutate(eventType = "CHAMPION KILL")

# Compute the median time to reach level 18
timeline.maxlvl <- match.events %>%
  dplyr::filter(eventType == "SKILL_LEVEL_UP") %>%
  mutate(teamId = ifelse(participantId <= 5, 100, 200)) %>%
  select(matchId, timestamp, teamId) %>%
  group_by(matchId, teamId) %>%
  mutate(rank = rank(timestamp, na.last = TRUE, ties.method = "first")) %>%
  dplyr::filter(rank == 5*18)

# Print proporitions of game reaching level 18
x <- length(unique(timeline.maxlvl$matchId))
n <- length(data.match$matchId)
print(x/n * 100)
# [1] 6.3

# Add to timeline
timeline.maxlvl <- timeline.maxlvl %>%
  as.data.frame() %>%
  summarise(timestamp = median(timestamp)) %>%
  mutate(eventType = "MAX LEVEL")

# Compute the median level reached
match.events %>%
  dplyr::filter(eventType == "SKILL_LEVEL_UP") %>%
  mutate(teamId = ifelse(participantId <= 5, 100, 200)) %>%
  select(matchId, timestamp, teamId) %>%
  group_by(matchId, teamId) %>%
  mutate(rank = rank(timestamp, na.last = TRUE, ties.method = "first")) %>%
  select(-timestamp) %>%
  summarise_each(funs(max(rank))) %>%
  as.data.frame() %>%
  summarise(rank = median(rank)/5)

#   rank
# 1 15.5

timeline <- rbind(timeline.monster, timeline.kill, timeline.maxlvl, timeline.surrender, timeline.tower)
            # timeline.inhibitor
timeline <- timeline[order(timeline$timestamp),]

#   timestamp          eventType
#       (dbl)              (chr)
# 1  3.154658      CHAMPION KILL
# 2 12.928967        DRAGON KILL
# 3 16.296100        HERALD KILL
# 4 25.475000          SURRENDER
# 5 29.355583         BARON KILL
# 6 33.416667 CASTLE DESTRUCTION
# 7 44.567367          MAX LEVEL
  
# Draw timeline
# http://stackoverflow.com/questions/7492274/draw-a-chronological-timeline-with-ggplot2

# dislocations <- sample(c(-1,-.5,.5,1), dim(timeline)[1], replace = T)
dislocations <- c(1.0, -1.0, 0.5, -0.5, 1.0, -1.0, 0.5, -0.5)
nudges <- 0.1 * sign(dislocations)

p <- ggplot(timeline) + 
  geom_text(aes(x = timestamp, y = dislocations, label = eventType), 
            position = position_nudge(y = nudges)) +
  geom_hline(yintercept = 0, color = gg_purple, size = 1) +
  geom_segment(aes(x = timestamp, y = dislocations, xend = timestamp, yend = 0)) +
  xlab("minutes") +
  scale_x_continuous(expand = c(.15, .15))

p <- p + 
  theme(panel.grid.minor.y = element_blank(),
        panel.grid.major.y = element_blank(),
        axis.line = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        axis.title.y = element_blank(),
        legend.position = "none")

print(p)
ggsave("figures/timeline.png", width = 8, height = 4.5, units = "in", bg = "transparent")
```

## Scatter plot

```{r}
# Delta fields refer to values for the specified period (e.g., the gold per minute over the first 10 minutes of the game versus the second 20 minutes of the game) 
# Diffs fields refer to the deltas versus the calculated lane opponent(s)

participants.timeline <- data.match %>%
  enter_object("participants") %>%
  gather_array("participants.index") %>%
  spread_values(participantId = jnumber("participantId"),
                teamId = jnumber("teamId")) %>%
  enter_object("timeline")

participants.creeps <- participants.timeline %>% 
  enter_object("creepsPerMinDeltas") %>%
  gather_keys("ParticipantTimelineData") %>%
  append_values_number("creepsPerMinDeltas")

participants.gold <- participants.timeline %>% 
  enter_object("goldPerMinDeltas") %>%
  gather_keys("ParticipantTimelineData") %>%
  append_values_number("goldPerMinDeltas")

# participants.wards <- participants.timeline %>% 
#   enter_object("wardsPerMinDeltas") %>%
#   gather_keys("ParticipantTimelineData") %>%
#   append_values_number("ParticipantTimelineValue")

participants.xp <- participants.timeline %>% 
  enter_object("xpPerMinDeltas") %>%
  gather_keys("ParticipantTimelineData") %>%
  append_values_number("xpPerMinDeltas")

# participants.kills <- participants.timeline %>% 
#   enter_object("assistedLaneKillsPerMinDeltas") %>%
#   gather_keys("ParticipantTimelineData") %>%
#   append_values_number("assistedLaneKillsPerMinDeltas")

participants <- merge(participants.creeps, participants.gold)
participants <- merge(participants, participants.xp)

participants <- merge(participants, match.winner) %>%
  select(matchId, teamId, ParticipantTimelineData, creepsPerMinDeltas, goldPerMinDeltas, xpPerMinDeltas, winner) %>%
  group_by(matchId, teamId, ParticipantTimelineData, winner) %>%
  summarise_each(funs(mean)) %>%
  dplyr::filter(ParticipantTimelineData == "zeroToTen" | ParticipantTimelineData == "tenToTwenty") %>%
  as.data.frame() %>%
  select(-ParticipantTimelineData) %>%
  group_by(matchId, teamId, winner) %>%
  summarise_each(funs(mean))

#       matchId teamId winner creepsPerMinDeltas goldPerMinDeltas xpPerMinDeltas
#         (dbl)  (dbl)  (lgl)              (dbl)            (dbl)          (dbl)
# 1  2054994176    100  FALSE               3.66           270.78         359.19
# 2  2054994176    200   TRUE               4.15           320.34         387.32
# 3  2054994196    100  FALSE               3.55           318.21         402.64
# 4  2054994196    200   TRUE               4.08           332.82         385.74
# 5  2054994244    100  FALSE               3.27           255.12         372.72
# 6  2054994244    200   TRUE               4.10           329.23         424.98
# 7  2054994283    100  FALSE               3.54           255.87         364.14
# 8  2054994283    200   TRUE               4.52           336.31         415.82
# 9  2054994354    100  FALSE               3.78           304.94         358.04
# 10 2054994354    200   TRUE               3.41           299.32         378.73
# ..        ...    ...    ...                ...              ...            ...

p <- ggplot(participants, aes(goldPerMinDeltas, xpPerMinDeltas, 
                              color = factor(winner), group = factor(winner))) + 
  geom_point(alpha = 0.2, size = 1) +
  geom_density2d(alpha = 1) +
  # stat_density2d() +
  # stat_density2d(aes(alpha = ..density..), geom = "raster", contour = FALSE)
  # geom_bin2d(aes(color = ..count..), binwidth = 5, alpha = 0.5) +
  # stat_bin2d(binwidth = 5, alpha = 0.5) +
  xlab("Gold per min in first 20 min") +
  ylab("Experience per min in first 20 min")

print(p)
ggsave("figures/scatter.png", width = 10, height = 5, units = "in", bg = "transparent")
```

## Prediction

We prepare the data frame with each row being one match and goal to predict winning team.
```{r}
data <- data.team %>%
  mutate(winner = winner * teamId,
         firstBaron = firstBaron * teamId,
         firstBlood = firstBlood * teamId,
         firstDragon = firstDragon * teamId,
         firstInhibitor = firstInhibitor * teamId,
         firstTower = firstTower * teamId,
         firstRiftHerald = firstRiftHerald * teamId) %>%
  group_by(matchId) %>%
  summarise_each(funs(sum)) %>%
  select(-teamId) %>%
  mutate_each(funs(factor)) %>%
  select(winner,
         # firstBaron,
         # firstInhibitor,
         firstBlood,
         firstDragon,
         firstTower,
         firstRiftHerald)
```

We divide the dataset into train and test.
```{r}
set.seed(1)

training.index <- createDataPartition(data$winner, p = .8, list = FALSE)
training <- data[ training.index,]
testing  <- data[-training.index,]

# Enough features?
nrow(training)/ncol(training)
```

We create dummy variables for categorical variables.
```{r}
# dummies <- dummyVars(~ ., data = training, sep = "__", drop2nd = TRUE)
# training <- data.frame(predict(dummies, training))
# testing <- data.frame(predict(dummies, testing))
# 
# # Enough features?
# nrow(training)/ncol(training)
```

We cross-validate.
```{r}
# Select method
# method <- "rf"
method <- "rpart"
# method <- "glmnet"
# method <- "svmLinear"
# method <- "svmRadial"

if (method == "rf") {
  modelGrid <- expand.grid(mtry = seq(0, 5, by = 1))
} else if (method == "rpart") {
  modelGrid <- expand.grid(cp = seq(0.01, 0.1, by = 0.01))
} else if (method == "glmnet") {
  # alpha between 0 (ridge) and 1 (lasso)
  modelGrid <- expand.grid(.alpha = c(0, 0.1, 0.5, 0.7, 1), .lambda = seq(0, 10, by = 0.1))
} else if (method == "svmLinear") {
  modelGrid <- expand.grid(C = seq(0.5, 5, by = 0.5))
} else if (method == "svmRadial") {
  modelGrid <- expand.grid(C = seq(0.5, 5, by = 0.5), sigma = seq(0.1, 0.5, by = 0.1))
}

# Cross-validation parameters
ctrl <- trainControl(method = "cv", number = 10, verboseIter = T)

# We can try different methods: svmLinear glmnet rpart svmRadial
modelTune <- train(winner ~ .,
                   data = training,
                   tuneGrid = modelGrid,
                   trControl = ctrl,
                   method = method,
                   # summaryFunction = twoClassSummary,
                   # metric = "ROC",
                   # classProbs = TRUE,
                   # importance = TRUE,
                   # scale = FALSE,
                   na.action = na.pass)

modelTune
varImp(modelTune)
plot(modelTune)

modelTune$bestTune
plot(modelTune$results)

par(mfrow = c(1,1))
plot(modelTune$finalModel)

fancyRpartPlot(modelTune$finalModel)
```

We evaluate using the ROC curve.
```{r}
probsTrain <- predict(modelTune,
                      training,
                      type = "prob",
                      na.action = na.pass)

rocCurve   <- roc(response = training$winner,
                      predictor = probsTrain$"200",
                      levels = rev(levels(training$winner)))

names(rocCurve)
rocCurve$thresholds
rocCurve$sensitivity

# Choose threshold according to sensitivity or specificity
# qplot(x = rocCurve$thresholds, y = rocCurve$sensit)
# qplot(x = rocCurve$thresholds, y = rocCurve$spec)

# Plot ROC curve
plot(rocCurve, print.thres = "best")
```

We now predict on the test set.
```{r}
modelPredict <- predict(modelTune,
                        newdata = testing,
                        # type = "prob",
                        na.action = na.pass)

# thresold <- 0.7
# modelPredict <- modelPredict %>%
#   mutate(class = ifelse("200" > thresold, "200", "100")) %>%
#   mutate(class = as.factor(class))

par(mfrow = c(1,1))
plot(modelPredict)

confusionMatrix(modelPredict, testing$winner, positive = "200")

# Show confusion matrix as table
CM.count <- table(predict = modelPredict, true = testing$winner)
attr(CM.count, "dimnames")$predict <- attr(CM.count, "dimnames")$predict %>%
  str_replace("100", "Predict Blue") %>%
  str_replace("200", "Predict Red")
attr(CM.count, "dimnames")$true <- attr(CM.count, "dimnames")$true %>%
  str_replace("100", "Win Blue") %>%
  str_replace("200", "Win Red")

# st <- c(CM.count["Predict Red","Win Red"] / 
#          (CM.count["Predict Red","Win Red"] + CM.count["Predict Blue","Win Red"]),
#        CM.count["Predict Blue","Win Blue"] / 
#          (CM.count["Predict Blue","Win Blue"] + CM.count["Predict Red","Win Blue"]))

# heat map with red and blue
p <- ggplot(melt(CM.count), aes(predict, true, fill = true)) + 
  geom_tile(aes(alpha = value)) +
  scale_y_discrete(labels = c("Win Red" = "Win Red\n65%","Win Blue" = "Win Blue\n75%")) +
  geom_text(aes(fill = true, label = value)) +
  scale_fill_manual(values = c(gg_blue, gg_red)) 
  # scale_fill_manual(values = c('blue','red')) 
  
print(p)

# facet_grid(st ~ .)

# Remove padding and decorations
p <- p +
  theme(axis.line = element_blank(),
        axis.ticks = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        legend.position = "none",
        panel.background = element_blank(),
        panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.background = element_blank())

plot(p)
ggsave("figures/predict.png", width = 4, height = 4, units = "in", bg = "transparent")

# CM.percent <- round(CM.count/length(testing$winner) * 100)
# CM.percent[1,1] <- paste(as.character(CM.percent[1,1]), "%")
# CM.percent[1,2] <- paste(as.character(CM.percent[1,2]), "%")
# CM.percent[2,1] <- paste(as.character(CM.percent[2,1]), "%")
# CM.percent[2,2] <- paste(as.character(CM.percent[2,2]), "%")

# png("figures/predict.png", bg = "transparent", res = 300, width = 1600, height = 900)
# grid.newpage()
# grid.table(CM.percent)
# dev.off()
```